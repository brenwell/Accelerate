{"version":3,"sources":["webpack:///webpack/bootstrap c3878532a0becf9ceb75","webpack:///./wheel/wheel.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,eAAe;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB;AACA,kCAAkC,GAAG,MAAM,MAAM,MAAM,SAAS,cAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"wheel_bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c3878532a0becf9ceb75","$(document).ready(function(){\n  main()\n})\n\n\nconst colors = [\n  0x9400D3, //Violet\n  0x4B0082, //Indigo\n  0x0000FF, //Blue\n  0x00FF00, //Green\t\n  0xFFFF00, //Yellow\n  0xFF7F00, //Orange\n  0xFF0000, //Red\n]\n\nconst PIE_ANGLE = 360 / colors.length\nconst PIE_MIDDLE = PIE_ANGLE / 2\nconst SPINS = 4 * 360 \nconst TIME_LENGTH = 4 //secs\nconst SPIN_DELAY = 1 //secs\nconst GROWTH = 1.1\n\nconst options = {\n\tbackgroundColor : 0xEEEEEE, \n  antialias: true\n}\n\nlet app;\nlet containerOuter;\nlet containerMiddle;\nlet containerInner;\n\nlet containerOuterWrapper;\nlet containerMiddleWrapper;\nlet containerInnerWrapper;\n\nlet button;\nlet tweenOuter;\nlet tweenMiddle;\nlet tweenInner;\n\nlet isSpinning = false\nlet timer\n\nfunction ContainerWrapper(container)\n{\n    this.container = container\n    this.rotateByDegrees = function(deg)\n    {\n        let rot = this.container.rotation \n        let newr = rot + degToRad(deg) /(Math.PI*2)\n        this.container.rotation = newr\n    }\n}\n\nfunction main()\n{\n    app = new PIXI.Application(600, 600, options);\n    document.body.appendChild(app.view);\n\n    containerOuter = makeContainer(300, 0xFFFFFF, -PIE_MIDDLE)\n    containerMiddle = makeContainer(210, 0xFFFFFF, -PIE_MIDDLE)\n    containerInner = makeContainer(120, 0xFFFFFF, -PIE_MIDDLE)\n\n    containerOuterWrapper = new ContainerWrapper(containerOuter)\n\n    app.stage.addChild(containerOuter)\n    app.stage.addChild(containerMiddle)\n    app.stage.addChild(containerInner)\n\n    addIndicator()  \n    addCenterButton()\n\n    // const ticker = new PIXI.ticker.Ticker();\n    // ticker.stop();\n    // ticker.add((deltaTime) => {\n    //     console.log(`pixi ticker: ${deltaTime}`)// do something every frame\n    // });\n    // ticker.start();\n}\nfunction makeContainer(radius, bg, startDeg)\n{\n    const container = new PIXI.Container()\n    container.pivot.x = 0\n    container.pivot.y = 0\n    container.x = 300\n    container.y = 300\n    \n    // draw outter background circle with given background\n    const circle = new PIXI.Graphics()\n    circle.beginFill(bg)\n    circle.lineStyle(10, bg);\n    circle.drawCircle(0,0,radius)\n    circle.endFill()\n    container.addChild(circle)\n\n    // draw inner background circle with white background\n    const mask = new PIXI.Graphics()\n    mask.beginFill(0xFFFFFF)\n    mask.drawCircle(0,0,radius)\n    mask.endFill()\n    container.addChild(mask)\n\n    // get the (x,y) coordinates of the point that bound the sectors\n    const coords = plotCirclePoints(colors.length, radius+50, -90)\n    const size = radius \n\n    coords.forEach(function(coord, i){   \n        const index = (i == coords.length-1) ? 0 : i+1\n        const nextCoord = coords[index]\n\n        // draw the triangular sector of the correct color - note we are working within container\n        const tri = new PIXI.Graphics()\n        tri.beginFill( colors[i], 0.8);\n        tri.moveTo(0, 0);\n        tri.lineTo(coord.x, coord.y);\n        tri.lineTo(nextCoord.x, nextCoord.y);\n        tri.lineTo(0, 0);\n        tri.endFill();\n        tri.mask = mask\n        container.addChild(tri);\n    })\n    \n    container.rotation = degToRad(startDeg)\n    return container;\n}\n/*\n* Add a triangular pointer to the top of the 'wheel'\n*/\nfunction addIndicator()\n{\n    const tri = new PIXI.Graphics()\n    tri.beginFill(0xFFFFFF);\n    tri.moveTo(0, 0);\n    tri.lineTo(30, 0);\n    tri.lineTo(15, 30);\n    tri.endFill();\n\n    const triContainer = new PIXI.Container()\n    triContainer.addChild(tri)\n    app.stage.addChild(triContainer)\n    triContainer.x = 300 - 15\n}\n\n/*\n* Add a center button to the wheel and hooks the press of that\n* button to the randon function\n*/\nfunction addCenterButton()\n{\n    const cir = new PIXI.Graphics()\n    cir.beginFill(0xFFFFFF);\n    cir.drawCircle(0,0,50)\n    cir.endFill();\n\n    const text = new PIXI.Text('Click',{fill: 0xFF66CC})\n    text.x = Math.round(-text.width/2)\n    text.y = -14\n\n    const cirContainer = new PIXI.Container()\n    cirContainer.addChild(cir)\n    cirContainer.addChild(text)\n    app.stage.addChild(cirContainer)\n    cirContainer.x = 300\n    cirContainer.y = 300\n\n    cirContainer.buttonMode = true\n    cirContainer.interactive = true\n    cirContainer.pointerup = function(){\n        spinAll()\n        // random()\n    }\n  button = text  \n}\nfunction rotateContainerOuter(deg)\n{\n    let rotO = containerOuter.rotation \n    let newrO = rotO + degToRad(10) /(Math.PI*2)\n    containerOuter.rotation = newrO\n}\nfunction calcNewRotation(container, delta)\n{\n    let rot = container.rotation \n    let new_r = rot + degToRad(delta) /(Math.PI*2)\n    return new_r\n}\nfunction spinAll()\n{\n    timer = setInterval(function(){\n        containerOuterWrapper.rotateByDegrees(30)\n        containerMiddleWrapper.rotateByDegrees(10)\n        containerInnerWrapper.rotateByDegrees(10)\n    }, 10)\n}\n\n/*\n* Starts the separate \"wheels\" spinning with a delay bewtween the start of each\n* Arranges for them to all come to a halt the appropriate dot index\n\n*/\nfunction spin(dot1Index, dot2Index, dot3Index)\n{\n\tif(isSpinning){\n        stop()\n        return\n    }\n    button.text = 'Stop'\n\n    let delay\n    let length = TIME_LENGTH\n  \n    isSpinning = true\n\n    delay = SPIN_DELAY * 0\n    tweenInner = spinTo(dot1Index, containerInner, length-delay, delay, function(){\n        isSpinning = false\n    })\n\t\n    delay = SPIN_DELAY * 1\n    tweenMiddle = spinTo( dot2Index, containerMiddle, length-delay, delay)\n\n    delay = SPIN_DELAY * 2\n    tweenOuter = spinTo( dot3Index, containerOuter, length-delay,delay)\n}\n\nfunction stop()\n{\n\ttweenOuter.totalProgress(0.8)\n\ttweenMiddle.totalProgress(0.8)\n\ttweenInner.totalProgress(0.8)\n    button.text = 'Spin'\n}\n\nfunction random()\n{\n\tspin(\n      \tMath.floor(Math.random()*colors.length),\n        Math.floor(Math.random()*colors.length),\n        Math.floor(Math.random()*colors.length)\n    )\n}\n\nfunction win(index)\n{\n\tspin(index,index,index)\n}\n\n/*\n* Spins a container or annulus so that it starts after delay\n* dotIndex  - the sector index at which to stop  \n* container - the contaier to spin\n*/\nfunction spinTo(dotIndex, container, length, delay, cb)\n{\n\n    let deg = SPINS + (PIE_ANGLE * dotIndex) - PIE_MIDDLE\n    const ease = CustomEase.create(\"custom\", \"M0,0,C0.398,0,0.284,1.034,1,1\")\n\n    let to = {\n        rotation: degToRad(deg),\n        ease: ease,\n        delay: delay,\n        onComplete: function(){\n            container.rotation -= degToRad(SPINS)\n            if( cb ) \n                cb()\n        }\n    }\n    // tween rotation property of container to degToRad(deg)\n    // using a custom easing after a delay\n    return TweenMax.to(container, length, to)\n\n    to = {\n        x: GROWTH,\n        y: GROWTH,\n        ease: ease,\n        delay: delay,\n        yoyo: true,\n        repeat: 1\n    }\n    TweenMax.to(container.scale, length/2, to)\n\n    return \n}\n\n\n\n// document.getElementById('button').addEventListener('click',random)\n\n// document.getElementById('select').addEventListener('change',function(e){\n// \twin(e.currentTarget.selectedIndex+1)\n// })\n\n\n// Helper functions\n/*\n* Divides a circle into a number of colored segments.\n* items     {int}   - number of segments\n* radius    {float} - radius of circle\n* rotation  {float} - degrees of rotation from initial position\n*\n* returns array of style objects {x:{float} , y:{float}, angle:{float radians} }\n* where each (x,y) lies on the circle of given radius and divide the circle into\n* items equal sized sectors.\n*\n* Normally the first sector boundary would be the point (0, radius) (12 oclock)\n* but offset the boundary points by \"rotation\" degrees to the right \n*/\nfunction plotCirclePoints(items, radius, rotation)\n{\n    const tmp = [];\n\n    for (let i = 0; i < items; i++)\n    {\n        const r = radius;\n        const rot = degToRad(rotation);\n\n        const x = r * Math.cos((2 * Math.PI * i / items) + rot);\n        const y = r * Math.sin((2 * Math.PI * i / items) + rot);\n\n        const offset = (x < 0) ? 270 : 90;\n        let angle = Math.atan(y / x) * 180 / Math.PI;\n\n        angle = angle + offset;\n        const style = {\n            x,\n            y,\n            // angle, - this is not used anywhere\n        };\n\n        tmp.push(style);\n    }\n\n    return tmp;\n}\n/*\n* Converts degrees to radians\n*/\nfunction degToRad(degrees)\n{\n    return degrees * Math.PI / 180;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./wheel/wheel.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}